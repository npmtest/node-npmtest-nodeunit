{"/home/travis/build/npmtest/node-npmtest-nodeunit/test.js":"/* istanbul instrument in package npmtest_nodeunit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodeunit/lib.npmtest_nodeunit.js":"/* istanbul instrument in package npmtest_nodeunit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nodeunit = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nodeunit = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nodeunit/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nodeunit && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nodeunit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nodeunit\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nodeunit.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nodeunit.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nodeunit.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nodeunit.__dirname + '/lib.npmtest_nodeunit.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/index.js":"// This file is just added for convenience so this repository can be\n// directly checked out into a project's deps folder\nmodule.exports = require('./lib/nodeunit');\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/nodeunit.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar async = require('../deps/async'),\n    types = require('./types'),\n    utils = require('./utils'),\n    core = require('./core'),\n    reporters = require('./reporters'),\n    assert = require('./assert'),\n    path = require('path'),\n    events = require('events');\n\n\n/**\n * Export sub-modules.\n */\n\nexports.types = types;\nexports.utils = utils;\nexports.reporters = reporters;\nexports.assert = assert;\n\n// backwards compatibility\nexports.testrunner = {\n    run: function () {\n        console.log(\n            'WARNING: nodeunit.testrunner is going to be deprecated, please ' +\n            'use nodeunit.reporters.default instead!'\n        );\n        return reporters['default'].run.apply(this, arguments);\n    }\n};\n\n\n/**\n * Export all core functions\n */\n\nfor (var k in core) {\n    exports[k] = core[k];\n};\n\n\n/**\n * Load modules from paths array and run all exported tests in series. If a path\n * is a directory, load all supported file types inside it as modules. This only\n * reads 1 level deep in the directory and does not recurse through\n * sub-directories.\n *\n * @param {Array} paths\n * @param {Object} opt\n * @api public\n */\n\nexports.runFiles = function (paths, opt) {\n    var all_assertions = [];\n    var options = types.options(opt);\n    var start = new Date().getTime();\n\n    if (!paths.length) {\n        return options.done(types.assertionList(all_assertions));\n    }\n\n    utils.modulePaths(paths, function (err, files) {\n        if (err) throw err;\n        async.concatSeries(files, function (file, cb) {\n            var name = path.basename(file);\n            exports.runModule(name, require(file), options, cb);\n        },\n        function (err, all_assertions) {\n            var end = new Date().getTime();\n            exports.done()\n            options.done(types.assertionList(all_assertions, end - start));\n        });\n    }, options.recursive);\n\n};\n\n/* Export all prototypes from events.EventEmitter */\nvar label;\nfor (label in events.EventEmitter.prototype) {\n  exports[label] = events.EventEmitter.prototype[label];\n}\n\n/* Emit event 'complete' on completion of a test suite. */\nexports.complete = function(name, assertions)\n{\n    exports.emit('complete', name, assertions);\n};\n\n/* Emit event 'complete' on completion of all tests. */\nexports.done = function()\n{\n    exports.emit('done');\n};\n\nmodule.exports = exports;\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/deps/async.js":"/*global setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root = this,\n        previous_async = root.async;\n\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    else {\n        root.async = async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    //// cross-browser compatiblity functions ////\n\n    var _forEach = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _forEach(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _forEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    var _indexOf = function (arr, item) {\n        if (arr.indexOf) {\n            return arr.indexOf(item);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            if (arr[i] === item) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof setImmediate === 'function') {\n        async.nextTick = function (fn) {\n            setImmediate(fn);\n        };\n    }\n    else if (typeof process !== 'undefined' && process.nextTick) {\n        async.nextTick = process.nextTick;\n    }\n    else {\n        async.nextTick = function (fn) {\n            setTimeout(fn, 0);\n        };\n    }\n\n    async.forEach = function (arr, iterator, callback) {\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _forEach(arr, function (x) {\n            iterator(x, function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed === arr.length) {\n                        callback();\n                    }\n                }\n            });\n        });\n    };\n\n    async.forEachSeries = function (arr, iterator, callback) {\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed === arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.forEach].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.forEachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.forEachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.forEach(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.forEach(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var completed = [];\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _forEach(listeners, function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (completed.length === keys.length) {\n                callback(null);\n            }\n        });\n\n        _forEach(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                if (err) {\n                    callback(err);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    completed.push(k);\n                    taskComplete();\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && _indexOf(completed, x) !== -1);\n                }, true);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        if (!tasks.length) {\n            return callback();\n        }\n        callback = callback || function () {};\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.nextTick(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    async.parallel = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args || null);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.forEach(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args || null);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.forEachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.queue = function (worker, concurrency) {\n        var workers = 0;\n        var tasks = [];\n        var q = {\n            concurrency: concurrency,\n            push: function (data, callback) {\n                tasks.push({data: data, callback: callback});\n                async.nextTick(q.process);\n            },\n            process: function () {\n                if (workers < q.concurrency && tasks.length) {\n                    var task = tasks.splice(0, 1)[0];\n                    workers += 1;\n                    worker(task.data, function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        q.process();\n                    });\n                }\n            },\n            length: function () {\n                return tasks.length;\n            }\n        };\n        return q;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _forEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else {\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    callback.apply(null, arguments);\n                }]));\n            }\n        };\n    };\n\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/types.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n *\n * THIS FILE SHOULD BE BROWSER-COMPATIBLE JS!\n * You can use @REMOVE_LINE_FOR_BROWSER to remove code from the browser build.\n * Only code on that line will be removed, it's mostly to avoid requiring code\n * that is node specific\n */\n\n/**\n * Module dependencies\n */\n\nvar assert = require('./assert'),     //@REMOVE_LINE_FOR_BROWSER\n    async = require('../deps/async'); //@REMOVE_LINE_FOR_BROWSER\n\n\n/**\n * Creates assertion objects representing the result of an assert call.\n * Accepts an object or AssertionError as its argument.\n *\n * @param {object} obj\n * @api public\n */\n\nexports.assertion = function (obj) {\n    return {\n        method: obj.method || '',\n        message: obj.message || (obj.error && obj.error.message) || '',\n        error: obj.error,\n        passed: function () {\n            return !this.error;\n        },\n        failed: function () {\n            return Boolean(this.error);\n        }\n    };\n};\n\n/**\n * Creates an assertion list object representing a group of assertions.\n * Accepts an array of assertion objects.\n *\n * @param {Array} arr\n * @param {Number} duration\n * @api public\n */\n\nexports.assertionList = function (arr, duration) {\n    var that = arr || [];\n    that.failures = function () {\n        var failures = 0;\n        for (var i = 0; i < this.length; i += 1) {\n            if (this[i].failed()) {\n                failures += 1;\n            }\n        }\n        return failures;\n    };\n    that.passes = function () {\n        return that.length - that.failures();\n    };\n    that.duration = duration || 0;\n    return that;\n};\n\n/**\n * Create a wrapper function for assert module methods. Executes a callback\n * after it's complete with an assertion object representing the result.\n *\n * @param {Function} callback\n * @api private\n */\n\nvar assertWrapper = function (callback) {\n    return function (new_method, assert_method, arity) {\n        return function () {\n            var message = arguments[arity - 1];\n            var a = exports.assertion({method: new_method, message: message});\n            try {\n                assert[assert_method].apply(null, arguments);\n            }\n            catch (e) {\n                a.error = e;\n            }\n            callback(a);\n        };\n    };\n};\n\n/**\n * Creates the 'test' object that gets passed to every test function.\n * Accepts the name of the test function as its first argument, followed by\n * the start time in ms, the options object and a callback function.\n *\n * @param {String} name\n * @param {Number} start\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\n\nexports.test = function (name, start, options, callback) {\n    var expecting;\n    var a_list = [];\n\n    var wrapAssert = assertWrapper(function (a) {\n        a_list.push(a);\n        if (options.log) {\n            async.nextTick(function () {\n                options.log(a);\n            });\n        }\n    });\n\n    var test = {\n        done: function (err) {\n            if (expecting !== undefined && expecting !== a_list.length) {\n                var e = new Error(\n                    'Expected ' + expecting + ' assertions, ' +\n                    a_list.length + ' ran'\n                );\n                var a1 = exports.assertion({method: 'expect', error: e});\n                a_list.push(a1);\n                if (options.log) {\n                    async.nextTick(function () {\n                        options.log(a1);\n                    });\n                }\n            }\n            if (err) {\n                var a2 = exports.assertion({error: err});\n                a_list.push(a2);\n                if (options.log) {\n                    async.nextTick(function () {\n                        options.log(a2);\n                    });\n                }\n            }\n            var end = new Date().getTime();\n            async.nextTick(function () {\n                var assertion_list = exports.assertionList(a_list, end - start);\n                options.testDone(name, assertion_list);\n                callback(null, a_list);\n            });\n        },\n        ok: wrapAssert('ok', 'ok', 2),\n        same: wrapAssert('same', 'deepEqual', 3),\n        equals: wrapAssert('equals', 'equal', 3),\n        expect: function (num) {\n            expecting = num;\n        },\n        _assertion_list: a_list\n    };\n    // add all functions from the assert module\n    for (var k in assert) {\n        if (assert.hasOwnProperty(k)) {\n            test[k] = wrapAssert(k, k, assert[k].length);\n        }\n    }\n    return test;\n};\n\n/**\n * Ensures an options object has all callbacks, adding empty callback functions\n * if any are missing.\n *\n * @param {Object} opt\n * @return {Object}\n * @api public\n */\n\nexports.options = function (opt) {\n    var optionalCallback = function (name) {\n        opt[name] = opt[name] || function () {};\n    };\n\n    optionalCallback('moduleStart');\n    optionalCallback('moduleDone');\n    optionalCallback('testStart');\n    optionalCallback('testReady');\n    optionalCallback('testDone');\n    //optionalCallback('log');\n\n    // 'done' callback is not optional.\n\n    return opt;\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/assert.js":"/**\n * This file is based on the node.js assert module, but with some small\n * changes for browser-compatibility\n * THIS FILE SHOULD BE BROWSER-COMPATIBLE JS!\n */\n\n\n/**\n * Added for browser compatibility\n */\n\nvar _keys = function(obj){\n    if(Object.keys) return Object.keys(obj);\n    if (typeof obj != 'object' && typeof obj != 'function') {\n        throw new TypeError('-');\n    }\n    var keys = [];\n    for(var k in obj){\n        if(obj.hasOwnProperty(k)) keys.push(k);\n    }\n    return keys;\n};\n\n\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = exports;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({message: message, actual: actual, expected: expected})\n\nassert.AssertionError = function AssertionError (options) {\n  this.name = \"AssertionError\";\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\n// code from util.inherits in node\nassert.AssertionError.super_ = Error;\n\n\n// EDITED FOR BROWSER COMPATIBILITY: replaced Object.create call\n// TODO: test what effect this may have\nvar ctor = function () { this.constructor = assert.AssertionError; };\nctor.prototype = Error.prototype;\nassert.AssertionError.prototype = new ctor();\n\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name+\":\", this.message].join(' ');\n  } else {\n    return [ this.name+\":\"\n           , typeof this.expected !== 'undefined' ? JSON.stringify(this.expected) : 'undefined'\n           , this.operator\n           , typeof this.actual !== 'undefined' ? JSON.stringify(this.actual) : 'undefined'\n           ].join(\" \");\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nassert.ok = function ok(value, message) {\n  if (!!!value) fail(value, true, message, \"==\", assert.ok);\n};\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \"==\", assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \"!=\", assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \"deepEqual\", assert.deepEqual);\n  }\n};\n\nvar Buffer = null;\nif (typeof require !== 'undefined' && typeof process !== 'undefined') {\n    try {\n        Buffer = require('buffer').Buffer;\n    }\n    catch (e) {\n        // May be a CommonJS environment other than Node.js\n        Buffer = null;\n    }\n}\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected)\n    return true;\n\n  // Convert to primitives, if supported\n  actual = actual.valueOf ? actual.valueOf() : actual;\n  expected = expected.valueOf ? expected.valueOf() : expected;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.2.1 If the expcted value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object that refers to the same source and options\n  } else if (actual instanceof RegExp && expected instanceof RegExp) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.ignoreCase === expected.ignoreCase &&\n           actual.multiline === expected.multiline;\n\n  } else if (Buffer && actual instanceof Buffer && expected instanceof Buffer) {\n    return (function() {\n      var i, len;\n\n      for (i = 0, len = expected.length; i < len; i++) {\n        if (actual[i] !== expected[i]) {\n          return false;\n        }\n      }\n      return actual.length === expected.length;\n    })();\n  // 7.3. Other pairs that do not both pass typeof value == \"object\",\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \"prototype\" property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull (value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments (object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv (a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n\n  // an identical \"prototype\" property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try{\n    var ka = _keys(a),\n      kb = _keys(b),\n      key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key] ))\n       return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \"notDeepEqual\", assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \"===\", assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as determined by !==.\n// assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \"!==\", assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual.message || actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail('Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail('Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function (err) { if (err) {throw err;}};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/utils.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar async = require('../deps/async'),\n    fs = require('fs'),\n    util = require('util'),\n    Script = require('vm').Script,\n    http = require('http'),\n    path = require('path');\n\n\n/**\n * Detect if coffee-script, iced-coffeescript, or streamline are available and \n * the respective file extensions to the search filter in modulePaths if it is.\n */\n\nvar extensions = [ 'js' ];  // js is always supported: add it unconditionally\nvar extensionPattern;\n\ntry {\n    require('coffee' + '-script/register');\n    extensions.push('coffee');\n} catch (e) { }\n\ntry {\n    require('iced-coffee' + '-script/register');\n    extensions.push('iced');\n} catch (e) { }\n\ntry {\n    require('stream' + 'line').register();\n    extensions.push('_coffee');\n    extensions.push('_js');\n} catch (e) { }\n\nextensionPattern = new RegExp('\\\\.(?:' + extensions.join('|') + ')$');\n\n\n/**\n * Finds all modules at each path in an array, If a path is a directory, it\n * returns all supported file types inside it. This only reads 1 level deep in\n * the directory and does not recurse through sub-directories.\n *\n * The extension (.js, .coffee etc) is stripped from the filenames so they can\n * simply be require()'ed.\n *\n * @param {Array} paths\n * @param {Function} callback\n * @param {Boolean=} recursive\n * @api public\n */\nexports.modulePaths = function modulePaths(paths, callback, recursive) {\n    recursive = (recursive === true);\n    async.concatSeries(paths, function (p, cb) {\n        fs.stat(p, function (err, stats) {\n            if (err) {\n                return cb(err);\n            }\n            if (stats.isFile()) {\n                return cb(null, [p]);\n            }\n            if (stats.isDirectory()) {\n                fs.readdir(p, function (err, files) {\n                    if (err) {\n                        return cb(err);\n                    }\n\n                    // filter out any filenames with unsupported extensions\n                    var modules = files.filter(function (filename) {\n                        return extensionPattern.exec(filename);\n                    });\n\n                    // remove extension from module name and prepend the\n                    // directory path\n                    var fullpaths = modules.map(function (filename) {\n                        var mod_name = filename.replace(extensionPattern, '');\n                        return [p, mod_name].join('/');\n                    });\n\n                    if (recursive) {\n                        // get all sub directories\n                        var directories =\n                            files\n                                .map(function(filename) {\n                                    // resolve path first\n                                    return path.resolve(p, filename);\n                                })\n                                .filter(function(filename) {\n                                    // fetch only directories\n                                    return (fs.statSync(filename).isDirectory());\n                                });\n\n                        // recursively call modulePaths() with sub directories\n                        modulePaths(directories, function(err, files) {\n                            if (!err) {\n                                cb(null, fullpaths.concat(files).sort())\n                            } else {\n                                cb(err);\n                            }\n                        }, recursive);\n                    } else {\n                        // sort filenames here, because Array.map changes order\n                        fullpaths.sort();\n\n                        // finish\n                        cb(null, fullpaths);\n                    }\n\n                });\n            }\n        });\n    }, callback);\n};\n\n/**\n * Evaluates JavaScript files in a sandbox, returning the context. The first\n * argument can either be a single filename or an array of filenames. If\n * multiple filenames are given their contents are concatenated before\n * evalution. The second argument is an optional context to use for the sandbox.\n *\n * @param files\n * @param {Object} sandbox\n * @return {Object}\n * @api public\n */\n\nexports.sandbox = function (files, /*optional*/sandbox) {\n    var source, script, result;\n    if (!(files instanceof Array)) {\n        files = [files];\n    }\n    source = files.map(function (file) {\n        return fs.readFileSync(file, 'utf8');\n    }).join('');\n\n    if (!sandbox) {\n        sandbox = {};\n    }\n    script = new Script(source);\n    result = script.runInNewContext(sandbox);\n    return sandbox;\n};\n\n/**\n * Provides a http request, response testing environment.\n *\n * Example:\n *\n *  var httputil = require('nodeunit').utils.httputil\n *  exports.testSomething = function(test) {\n *    httputil(function (req, resp) {\n *        resp.writeHead(200, {});\n *        resp.end('test data');\n *      },\n *      function(server, client) {\n *        client.fetch('GET', '/', {}, function(resp) {\n *          test.equal('test data', resp.body);\n *          server.close();\n *          test.done();\n *        })\n *      });\n *  };\n *\n * @param {Function} cgi\n * @param {Function} envReady\n * @api public\n */\nexports.httputil = function (cgi, envReady) {\n    var hostname = process.env.HOSTNAME || 'localhost';\n    var port = process.env.PORT || 3000;\n\n    var server = http.createServer(cgi);\n    server.listen(port, hostname);\n\n    var agent = new http.Agent({ host: hostname, port: port, maxSockets: 1 });\n    var client = {\n        fetch: function (method, path, headers, respReady) {\n            var request = http.request({\n                host: hostname,\n                port: port,\n                agent: agent,\n                method: method,\n                path: path,\n                headers: headers\n            });\n            request.end();\n            request.on('response', function (response) {\n                response.setEncoding('utf8');\n                response.on('data', function (chunk) {\n                    if (response.body) {\n                        response.body += chunk;\n                    } else {\n                        response.body = chunk;\n                    }\n                });\n                response.on('end', function () {\n                    if (response.headers['content-type'] === 'application/json') {\n                        response.bodyAsObject = JSON.parse(response.body);\n                    }\n                    respReady(response);\n                });\n            });\n        }\n    };\n\n    process.nextTick(function () {\n        if (envReady && typeof envReady === 'function') {\n            envReady(server, client);\n        }\n    });\n};\n\n\n/**\n * Improves formatting of AssertionError messages to make deepEqual etc more\n * readable.\n *\n * @param {Object} assertion\n * @return {Object}\n * @api public\n */\n\nexports.betterErrors = function (assertion) {\n    if (!assertion.error) {\n        return assertion;\n    }\n    var e = assertion.error;\n\n    if (typeof e.actual !== 'undefined' && typeof e.expected !== 'undefined') {\n        var actual = util.inspect(e.actual, false, 10).replace(/\\n$/, '');\n        var expected = util.inspect(e.expected, false, 10).replace(/\\n$/, '');\n\n        var multiline = (\n            actual.indexOf('\\n') !== -1 ||\n            expected.indexOf('\\n') !== -1\n        );\n        var spacing = (multiline ? '\\n' : ' ');\n        e._message = e.message;\n        e.stack = (\n            e.name + ':' + spacing +\n            actual + spacing + e.operator + spacing +\n            expected + '\\n' +\n            e.stack.split('\\n').slice(1).join('\\n')\n        );\n    }\n    return assertion;\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/core.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n *\n * THIS FILE SHOULD BE BROWSER-COMPATIBLE JS!\n * You can use @REMOVE_LINE_FOR_BROWSER to remove code from the browser build.\n * Only code on that line will be removed, it's mostly to avoid requiring code\n * that is node specific\n */\n\n/**\n * Module dependencies\n */\n\nvar async    = require('../deps/async'), //@REMOVE_LINE_FOR_BROWSER\n    nodeunit = require('./nodeunit'),    //@REMOVE_LINE_FOR_BROWSER\n    types    = require('./types');       //@REMOVE_LINE_FOR_BROWSER\n\n\n/**\n * Added for browser compatibility\n */\n\nvar _keys = function (obj) {\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    var keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            keys.push(k);\n        }\n    }\n    return keys;\n};\n\n\nvar _copy = function (obj) {\n    var nobj = {};\n    var keys = _keys(obj);\n    for (var i = 0; i <  keys.length; i += 1) {\n        nobj[keys[i]] = obj[keys[i]];\n    }\n    return nobj;\n};\n\n\n/**\n * Runs a test function (fn) from a loaded module. After the test function\n * calls test.done(), the callback is executed with an assertionList as its\n * second argument.\n *\n * @param {String} name\n * @param {Function} fn\n * @param {Object} opt\n * @param {Function} callback\n * @api public\n */\n\nexports.runTest = function (name, fn, opt, callback) {\n    var options = types.options(opt);\n\n    options.testStart(name);\n    var start = new Date().getTime();\n    var test = types.test(name, start, options, callback);\n\n    options.testReady(test);\n    try {\n        fn(test);\n    }\n    catch (e) {\n        test.done(e);\n    }\n};\n\n/**\n * Takes an object containing test functions or other test suites as properties\n * and runs each in series. After all tests have completed, the callback is\n * called with a list of all assertions as the second argument.\n *\n * If a name is passed to this function it is prepended to all test and suite\n * names that run within it.\n *\n * @param {String} name\n * @param {Object} suite\n * @param {Object} opt\n * @param {Function} callback\n * @api public\n */\n\nexports.runSuite = function (name, suite, opt, callback) {\n    suite = wrapGroup(suite);\n    var keys = _keys(suite);\n\n    async.concatSeries(keys, function (k, cb) {\n        var prop = suite[k], _name;\n\n        _name = name ? [].concat(name, k) : [k];\n        _name.toString = function () {\n            // fallback for old one\n            return this.join(' - ');\n        };\n\n        if (typeof prop === 'function') {\n            var in_name = false,\n                in_specific_test = (_name.toString() === opt.testFullSpec) ? true : false;\n            for (var i = 0; i < _name.length; i += 1) {\n                if (_name[i] === opt.testspec) {\n                    in_name = true;\n                }\n            }\n\n            if ((!opt.testFullSpec || in_specific_test) && (!opt.testspec || in_name)) {\n                if (opt.moduleStart) {\n                    opt.moduleStart();\n                }\n                exports.runTest(_name, suite[k], opt, cb);\n            }\n            else {\n                return cb();\n            }\n        }\n        else {\n            exports.runSuite(_name, suite[k], opt, cb);\n        }\n    }, callback);\n};\n\n/**\n * Run each exported test function or test suite from a loaded module.\n *\n * @param {String} name\n * @param {Object} mod\n * @param {Object} opt\n * @param {Function} callback\n * @api public\n */\n\nexports.runModule = function (name, mod, opt, callback) {\n    var options = _copy(types.options(opt));\n\n    var _run = false;\n    var _moduleStart = options.moduleStart;\n\n    mod = wrapGroup(mod);\n\n    function run_once() {\n        if (!_run) {\n            _run = true;\n            _moduleStart(name);\n        }\n    }\n    options.moduleStart = run_once;\n\n    var start = new Date().getTime();\n\n    exports.runSuite(null, mod, options, function (err, a_list) {\n        var end = new Date().getTime();\n        var assertion_list = types.assertionList(a_list, end - start);\n        options.moduleDone(name, assertion_list);\n        if (nodeunit.complete) {\n            nodeunit.complete(name, assertion_list);\n        }\n        callback(null, a_list);\n    });\n};\n\n/**\n * Treats an object literal as a list of modules keyed by name. Runs each\n * module and finished with calling 'done'. You can think of this as a browser\n * safe alternative to runFiles in the nodeunit module.\n *\n * @param {Object} modules\n * @param {Object} opt\n * @api public\n */\n\n// TODO: add proper unit tests for this function\nexports.runModules = function (modules, opt) {\n    var all_assertions = [];\n    var options = types.options(opt);\n    var start = new Date().getTime();\n\n    async.concatSeries(_keys(modules), function (k, cb) {\n        exports.runModule(k, modules[k], options, cb);\n    },\n    function (err, all_assertions) {\n        var end = new Date().getTime();\n        options.done(types.assertionList(all_assertions, end - start));\n    });\n};\n\n\n/**\n * Wraps a test function with setUp and tearDown functions.\n * Used by testCase.\n *\n * @param {Function} setUp\n * @param {Function} tearDown\n * @param {Function} fn\n * @api private\n */\n\nvar wrapTest = function (setUp, tearDown, fn) {\n    return function (test) {\n        var context = {};\n        if (tearDown) {\n            var done = test.done;\n            test.done = function (err) {\n                try {\n                    tearDown.call(context, function (err2) {\n                        if (err && err2) {\n                            test._assertion_list.push(\n                                types.assertion({error: err})\n                            );\n                            return done(err2);\n                        }\n                        done(err || err2);\n                    });\n                }\n                catch (e) {\n                    done(e);\n                }\n            };\n        }\n        if (setUp) {\n            setUp.call(context, function (err) {\n                if (err) {\n                    return test.done(err);\n                }\n                fn.call(context, test);\n            });\n        }\n        else {\n            fn.call(context, test);\n        }\n    };\n};\n\n\n/**\n * Returns a serial callback from two functions.\n *\n * @param {Function} funcFirst\n * @param {Function} funcSecond\n * @api private\n */\n\nvar getSerialCallback = function (fns) {\n    if (!fns.length) {\n        return null;\n    }\n    return function (callback) {\n        var that = this;\n        var bound_fns = [];\n        for (var i = 0, len = fns.length; i < len; i++) {\n            (function (j) {\n                bound_fns.push(function () {\n                    return fns[j].apply(that, arguments);\n                });\n            })(i);\n        }\n        return async.series(bound_fns, callback);\n    };\n};\n\n\n/**\n * Wraps a group of tests with setUp and tearDown functions.\n * Used by testCase.\n *\n * @param {Object} group\n * @param {Array} setUps - parent setUp functions\n * @param {Array} tearDowns - parent tearDown functions\n * @api private\n */\n\nvar wrapGroup = function (group, setUps, tearDowns) {\n    var tests = {};\n\n    var setUps = setUps ? setUps.slice(): [];\n    var tearDowns = tearDowns ? tearDowns.slice(): [];\n\n    if (group.setUp) {\n        setUps.push(group.setUp);\n        delete group.setUp;\n    }\n    if (group.tearDown) {\n        tearDowns.unshift(group.tearDown);\n        delete group.tearDown;\n    }\n\n    var keys = _keys(group);\n\n    for (var i = 0; i < keys.length; i += 1) {\n        var k = keys[i];\n        if (typeof group[k] === 'function') {\n            tests[k] = wrapTest(\n                getSerialCallback(setUps),\n                getSerialCallback(tearDowns),\n                group[k]\n            );\n        }\n        else if (typeof group[k] === 'object') {\n            tests[k] = wrapGroup(group[k], setUps, tearDowns);\n        }\n    }\n    return tests;\n};\n\n\n/**\n * Backwards compatibility for test suites using old testCase API\n */\n\nexports.testCase = function (suite) {\n    return suite;\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/index.js":"// This is a hack to make browserify skip tap\nvar tap;\ntry {\n    tap = require('./' + 'tap');\n} catch (ex) {\n    tap = {\n        run: function() {\n            throw new Error('Sorry, tap reporter not available');\n        }\n    };\n}\n\nmodule.exports = {\n    'junit': require('./junit'),\n    'default': require('./default'),\n    'skip_passed': require('./skip_passed'),\n    'minimal': require('./minimal'),\n    'html': require('./html'),\n    'eclipse': require('./eclipse'),\n    'machineout': require('./machineout'),\n    'tap': tap,\n    'nested': require('./nested'),\n    'verbose' : require('./verbose'),\n    'lcov' : require('./lcov')\n    // browser test reporter is not listed because it cannot be used\n    // with the command line tool, only inside a browser.\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/tap.js":"/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    path = require('path'),\n    assert = require('tap').assert,\n    tap = require('tap'),\n    fs = require('fs');\n\n/**\n * Reporter info string\n */\n\nexports.info = \"TAP output\";\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    if (!options) {\n        // load default options\n        var content = fs.readFileSync(\n            __dirname + '/../../bin/nodeunit.json', 'utf8'\n        );\n        options = JSON.parse(content);\n    }\n\n    var paths = files.map(function (p) {\n        return path.resolve(p);\n    });\n\n    tap.pipe(process.stdout);\n\n    nodeunit.runFiles(paths, {\n        testStart: function (name) {\n            tap.comment(name.toString());\n        },\n        testDone: function (name, assertions) {\n            assertions.forEach(function (e) {\n                var extra = {};\n                if (e.error) {\n                    extra.error = {\n                        name: e.error.name,\n                        message: e.error.message,\n                        stack: e.error.stack.split(/\\n/).filter(function (line) {\n                            // exclude line of \"types.js\"\n                            return ! RegExp(/types.js:83:39/).test(line);\n                        }).join('\\n')\n                    };\n                    extra.wanted = e.error.expected;\n                    extra.found = e.error.actual;\n                }\n                tap.assert(e.passed(), e.message, extra);\n            });\n        },\n        done: function (assertions) {\n            tap.end();\n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/junit.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    path = require('path'),\n    async = require('../../deps/async'),\n    AssertionError = require('../assert').AssertionError,\n    child_process = require('child_process'),\n    ejs = require('ejs');\n\n\n/**\n * Reporter info string\n */\n\nexports.info = \"jUnit XML test reports\";\n\n\n/**\n * Ensures a directory exists using mkdir -p.\n *\n * @param {String} path\n * @param {Function} callback\n * @api private\n */\n\nvar ensureDir = function (path, callback) {\n    var mkdir = child_process.spawn('mkdir', ['-p', path]);\n    mkdir.on('error', function (err) {\n        callback(err);\n        callback = function(){};\n    });\n    mkdir.on('exit', function (code) {\n        if (code === 0) callback();\n        else callback(new Error('mkdir exited with code: ' + code));\n    });\n};\n\n\n/**\n * Returns absolute version of a path. Relative paths are interpreted\n * relative to process.cwd() or the cwd parameter. Paths that are already\n * absolute are returned unaltered.\n *\n * @param {String} p\n * @param {String} cwd\n * @return {String}\n * @api public\n */\n\nvar abspath = function (p, /*optional*/cwd) {\n    if (p[0] === '/') return p;\n    cwd = cwd || process.cwd();\n    return path.normalize(path.resolve(p));\n};\n\n\n/**\n * Run all tests within each module, reporting the results to the command-line,\n * then writes out junit-compatible xml documents.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, opts, callback) {\n    if (!opts.output) {\n        console.error(\n            'Error: No output directory defined.\\n' +\n            '\\tEither add an \"output\" property to your nodeunit.json config ' +\n            'file, or\\n\\tuse the --output command line option.'\n        );\n        return;\n    }\n    opts.output = abspath(opts.output);\n    var error = function (str) {\n        return opts.error_prefix + str + opts.error_suffix;\n    };\n    var ok    = function (str) {\n        return opts.ok_prefix + str + opts.ok_suffix;\n    };\n    var bold  = function (str) {\n        return opts.bold_prefix + str + opts.bold_suffix;\n    };\n\n    var start = new Date().getTime();\n    var paths = files.map(function (p) {\n        return path.resolve(p);\n    });\n\n    var modules = {}\n    var curModule;\n\n    nodeunit.runFiles(paths, {\n        testspec: opts.testspec,\n        testFullSpec: opts.testFullSpec,\n        moduleStart: function (name) {\n            curModule = {\n                errorCount: 0,\n                failureCount: 0,\n                tests: 0,\n                testcases: [],\n                name: name\n            };\n            modules[name] = curModule;\n        },\n        testDone: function (name, assertions) {\n            var testcase = {name: name};\n            for (var i=0; i<assertions.length; i++) {\n                var a = assertions[i];\n                if (a.failed()) {\n                    a = utils.betterErrors(a);\n                    testcase.failure = {\n                        message: a.message,\n                        backtrace: a.error.stack\n                    };\n\n                    if (a.error instanceof AssertionError) {\n                        curModule.failureCount++;\n                    }\n                    else {\n                        curModule.errorCount++;\n                    }\n                    break;\n                }\n            }\n            curModule.tests++;\n            curModule.testcases.push(testcase);\n        },\n        done: function (assertions) {\n            var end = new Date().getTime();\n            var duration = end - start;\n\n            ensureDir(opts.output, function (err) {\n                var tmpl = __dirname + \"/../../share/junit.xml.ejs\";\n                fs.readFile(tmpl, function (err, data) {\n                    if (err) throw err;\n                    var tmpl = data.toString();\n                    for(var k in modules) {\n                        var module = modules[k];\n                        var rendered = ejs.render(tmpl, {\n                            locals: {suites: [module]}\n                        });\n                        var filename = path.resolve(\n                            opts.output,\n                            module.name + '.xml'\n                        );\n                        console.log('Writing ' + filename);\n                        fs.writeFileSync(filename, rendered, 'utf8');\n                    }\n                    if (assertions.failures()) {\n                        console.log(\n                            '\\n' + bold(error('FAILURES: ')) +\n                            assertions.failures() + '/' +\n                            assertions.length + ' assertions failed (' +\n                            assertions.duration + 'ms)'\n                    \t);\n                    }\n                    else {\n                        console.log(\n                            '\\n' + bold(ok('OK: ')) + assertions.length +\n                            ' assertions (' + assertions.duration + 'ms)'\n                        );\n                    }\n                    \n                    if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n                });\n            });\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/default.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    track = require('../track'),\n    path = require('path'),\n    AssertionError = require('../assert').AssertionError;\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Default tests reporter\";\n\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    if (!options) {\n        // load default options\n        var content = fs.readFileSync(\n            __dirname + '/../../bin/nodeunit.json', 'utf8'\n        );\n        options = JSON.parse(content);\n    }\n\n    var error = function (str) {\n        return options.error_prefix + str + options.error_suffix;\n    };\n    var ok    = function (str) {\n        return options.ok_prefix + str + options.ok_suffix;\n    };\n    var bold  = function (str) {\n        return options.bold_prefix + str + options.bold_suffix;\n    };\n    var assertion_message = function (str) {\n        return options.assertion_prefix + str + options.assertion_suffix;\n    };\n    var pass_indicator = process.platform === 'win32' ? '\\u221A' : '';\n    var fail_indicator = process.platform === 'win32' ? '\\u00D7' : '';\n\n    var start = new Date().getTime();\n    var tracker = track.createTracker(function (tracker) {\n        if (tracker.unfinished()) {\n            console.log('');\n            console.log(error(bold(\n                'FAILURES: Undone tests (or their setups/teardowns): '\n            )));\n            var names = tracker.names();\n            for (var i = 0; i < names.length; i += 1) {\n                console.log('- ' + names[i]);\n            }\n            console.log('');\n            console.log('To fix this, make sure all tests call test.done()');\n            process.reallyExit(tracker.unfinished());\n        }\n    });\n\n\tvar opts = {\n\t    testspec: options.testspec,\n\t    testFullSpec: options.testFullSpec,\n        recursive: options.recursive,\n        moduleStart: function (name) {\n            console.log('\\n' + bold(name));\n        },\n        testDone: function (name, assertions) {\n            tracker.remove(name);\n\n            if (!assertions.failures()) {\n                console.log(pass_indicator + ' ' + name);\n            }\n            else {\n                console.log(error(fail_indicator + ' ' + name) + '\\n');\n                assertions.forEach(function (a) {\n                    if (a.failed()) {\n                        a = utils.betterErrors(a);\n                        if (a.error instanceof AssertionError && a.message) {\n                            console.log(\n                                'Assertion Message: ' +\n                                assertion_message(a.message)\n                            );\n                        }\n                        console.log(a.error.stack + '\\n');\n                    }\n                });\n            }\n        },\n        done: function (assertions, end) {\n            var end = end || new Date().getTime();\n            var duration = end - start;\n            if (assertions.failures()) {\n                console.log(\n                    '\\n' + bold(error('FAILURES: ')) + assertions.failures() +\n                    '/' + assertions.length + ' assertions failed (' +\n                    assertions.duration + 'ms)'\n                );\n            }\n            else {\n                console.log(\n                   '\\n' + bold(ok('OK: ')) + assertions.length +\n                   ' assertions (' + assertions.duration + 'ms)'\n                );\n            }\n\n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        },\n        testStart: function(name) {\n            tracker.put(name);\n        }\n    };\n\tif (files && files.length) {\n\t    var paths = files.map(function (p) {\n\t        return path.resolve(p);\n\t    });\n\t    nodeunit.runFiles(paths, opts);\n\t} else {\n\t\tnodeunit.runModules(files,opts);\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/track.js":"/*!\n * Simple util module to track tests. Adds a process.exit hook to print\n * the undone tests.\n */\n\n\nexports.createTracker = function (on_exit) {\n    var names = {};\n    var tracker = {\n        names: function () {\n            var arr = [];\n            for (var k in names) {\n                if (names.hasOwnProperty(k)) {\n                    arr.push(k);\n                }\n            }\n            return arr;\n        },\n        unfinished: function () {\n            return tracker.names().length;\n        },\n        put: function (testname) {\n            names[testname] = testname;\n        },\n        remove: function (testname) {\n            delete names[testname];\n        }\n    };\n\n    process.on('exit', function() {\n        on_exit = on_exit || exports.default_on_exit;\n        on_exit(tracker);\n    });\n\n    return tracker;\n};\n\nexports.default_on_exit = function (tracker) {\n    if (tracker.unfinished()) {\n        console.log('');\n        console.log('Undone tests (or their setups/teardowns): ');\n        var names = tracker.names();\n        for (var i = 0; i < names.length; i += 1) {\n            console.log(names[i]);\n        }\n        process.reallyExit(tracker.unfinished());\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/skip_passed.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    path = require('path'),\n    AssertionError = require('../assert').AssertionError;\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Skip passed tests output\";\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    if (!options) {\n        // load default options\n        var content = fs.readFileSync(\n            __dirname + '/../../bin/nodeunit.json', 'utf8'\n        );\n        options = JSON.parse(content);\n    }\n\n    var error = function (str) {\n        return options.error_prefix + str + options.error_suffix;\n    };\n    var ok    = function (str) {\n        return options.ok_prefix + str + options.ok_suffix;\n    };\n    var bold  = function (str) {\n        return options.bold_prefix + str + options.bold_suffix;\n    };\n    var assertion_message = function (str) {\n        return options.assertion_prefix + str + options.assertion_suffix;\n    };\n    var pass_indicator = process.platform === 'win32' ? '\\u221A' : '';\n    var fail_indicator = process.platform === 'win32' ? '\\u00D7' : '';\n\n    var start = new Date().getTime();\n    var paths = files.map(function (p) {\n        return path.resolve(p);\n    });\n\n    nodeunit.runFiles(paths, {\n        testspec: options.testspec,\n        testFullSpec: options.testFullSpec,\n        moduleStart: function (name) {\n            console.log('\\n' + bold(name));\n        },\n        testDone: function (name, assertions) {\n            if (assertions.failures()) {\n                console.log(error(fail_indicator + ' ' + name) + '\\n');\n                assertions.forEach(function (a) {\n                    if (a.failed()) {\n                        a = utils.betterErrors(a);\n                        if (a.error instanceof AssertionError && a.message) {\n                            console.log(\n                                'Assertion Message: ' + assertion_message(a.message)\n                            );\n                        }\n                        console.log(a.error.stack + '\\n');\n                    }\n                });\n            }\n        },\n        moduleDone: function (name, assertions) {\n            if (!assertions.failures()) {\n                console.log(pass_indicator + ' all tests passed');\n            }\n            else {\n                console.log(error(fail_indicator + ' some tests failed'));\n            }\n        },\n        done: function (assertions) {\n            var end = new Date().getTime();\n            var duration = end - start;\n            if (assertions.failures()) {\n                console.log(\n                    '\\n' + bold(error('FAILURES: ')) + assertions.failures() +\n                    '/' + assertions.length + ' assertions failed (' +\n                    assertions.duration + 'ms)'\n                );\n            }\n            else {\n                console.log(\n                    '\\n' + bold(ok('OK: ')) + assertions.length +\n                    ' assertions (' + assertions.duration + 'ms)'\n                );\n            }\n\n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/minimal.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    path = require('path'),\n    track = require('../track'),\n    AssertionError = require('../assert').AssertionError;\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Pretty minimal output\";\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    if (!options) {\n        // load default options\n        var content = fs.readFileSync(\n            __dirname + '/../../bin/nodeunit.json', 'utf8'\n        );\n        options = JSON.parse(content);\n    }\n\n    var red   = function (str) {\n        return options.error_prefix + str + options.error_suffix;\n    };\n    var green = function (str) {\n        return options.ok_prefix + str + options.ok_suffix;\n    };\n    var magenta = function (str) {\n        return options.assertion_prefix + str + options.assertion_suffix;\n    };\n    var bold  = function (str) {\n        return options.bold_prefix + str + options.bold_suffix;\n    };\n\n    var start = new Date().getTime();\n\n    var tracker = track.createTracker(function (tracker) {\n        if (tracker.unfinished()) {\n            console.log('');\n            console.log(bold(red(\n                'FAILURES: Undone tests (or their setups/teardowns): '\n            )));\n            var names = tracker.names();\n            for (var i = 0; i < names.length; i += 1) {\n                console.log('- ' + names[i]);\n            }\n            console.log('');\n            console.log('To fix this, make sure all tests call test.done()');\n            process.reallyExit(tracker.unfinished());\n        }\n    });\n\n\n\tvar opts = {\n\t    testspec: options.testspec,\n\t    testFullSpec: options.testFullSpec,\n        moduleStart: function (name) {\n            process.stdout.write(bold(name) + ': ');\n        },\n        moduleDone: function (name, assertions) {\n            console.log('');\n            if (assertions.failures()) {\n                assertions.forEach(function (a) {\n                    if (a.failed()) {\n                        a = utils.betterErrors(a);\n                        if (a.error instanceof AssertionError && a.message) {\n                            console.log(\n                                'Assertion in test ' + bold(a.testname) + ': ' +\n                                magenta(a.message)\n                            );\n                        }\n                        console.log(a.error.stack + '\\n');\n                    }\n                });\n            }\n\n        },\n        testStart: function (name) {\n            tracker.put(name);\n        },\n        testDone: function (name, assertions) {\n            tracker.remove(name);\n\n            if (!assertions.failures()) {\n                process.stdout.write('.');\n            }\n            else {\n                process.stdout.write(red('F'));\n                assertions.forEach(function (assertion) {\n                    assertion.testname = name;\n                });\n            }\n        },\n        done: function (assertions) {\n            var end = new Date().getTime();\n            var duration = end - start;\n            if (assertions.failures()) {\n                console.log(\n                    '\\n' + bold(red('FAILURES: ')) + assertions.failures() +\n                    '/' + assertions.length + ' assertions failed (' +\n                    assertions.duration + 'ms)'\n                );\n            }\n            else {\n                console.log(\n                    '\\n' + bold(green('OK: ')) + assertions.length +\n                    ' assertions (' + assertions.duration + 'ms)'\n                );\n            }\n\n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        }\n    };\n\n\tif (files && files.length) {\n      var paths = files.map(function (p) {\n          return path.resolve(p);\n      });\n\t    nodeunit.runFiles(paths, opts);\n\t} else {\n\t\tnodeunit.runModules(files,opts);\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/html.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    path = require('path'),\n    AssertionError = require('../assert').AssertionError;\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Report tests result as HTML\";\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    var start = new Date().getTime();\n    var paths = files.map(function (p) {\n        return path.resolve(p);\n    });\n\n    console.log('<html>');\n    console.log('<head>');\n    console.log('<title></title>');\n    console.log('<style type=\"text/css\">');\n    console.log('body { font: 12px Helvetica Neue }');\n    console.log('h2 { margin:0 ; padding:0 }');\n    console.log('pre { font: 11px Andale Mono; margin-left: 1em; padding-left: 1em; margin-top:0; font-size:smaller;}');\n    console.log('.assertion_message { margin-left: 1em; }');\n    console.log('  ol {' +\n    '\tlist-style: none;' +\n    '\tmargin-left: 1em;' +\n    '\tpadding-left: 1em;' +\n    '\ttext-indent: -1em;' +\n    '}');\n    console.log('  ol li.pass:before { content: \"\\\\2714 \\\\0020\"; }');\n    console.log('  ol li.fail:before { content: \"\\\\2716 \\\\0020\"; }');\n    console.log('</style>');\n    console.log('</head>');\n    console.log('<body>');\n    nodeunit.runFiles(paths, {\n        testspec: options.testspec,\n        testFullSpec: options.testFullSpec,\n        moduleStart: function (name) {\n            console.log('<h2>' + name + '</h2>');\n            console.log('<ol>');\n        },\n        testDone: function (name, assertions) {\n            if (!assertions.failures()) {\n                console.log('<li class=\"pass\">' + name + '</li>');\n            }\n            else {\n                console.log('<li class=\"fail\">' + name);\n                assertions.forEach(function (a) {\n                    if (a.failed()) {\n                        a = utils.betterErrors(a);\n                        if (a.error instanceof AssertionError && a.message) {\n                            console.log('<div class=\"assertion_message\">' +\n                                'Assertion Message: ' + a.message +\n                            '</div>');\n                        }\n                        console.log('<pre>');\n                        console.log(a.error.stack);\n                        console.log('</pre>');\n                    }\n                });\n                console.log('</li>');\n            }\n        },\n        moduleDone: function () {\n            console.log('</ol>');\n        },\n        done: function (assertions) {\n            var end = new Date().getTime();\n            var duration = end - start;\n            if (assertions.failures()) {\n                console.log(\n                    '<h3>FAILURES: '  + assertions.failures() +\n                    '/' + assertions.length + ' assertions failed (' +\n                    assertions.duration + 'ms)</h3>'\n                );\n            }\n            else {\n                console.log(\n                    '<h3>OK: ' + assertions.length +\n                    ' assertions (' + assertions.duration + 'ms)</h3>'\n                );\n            }\n            console.log('</body>');\n            console.log('</html>');\n\n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/eclipse.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    track = require('../track'),\n    path = require('path'),\n    AssertionError = require('../assert').AssertionError;\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Reporter for eclipse plugin\";\n\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    var start = new Date().getTime();\n    var paths = files.map(function (p) {\n        if (p.indexOf('/') === 0) {\n            return p;\n        }\n        return path.resolve(p);\n    });\n    var tracker = track.createTracker(function (tracker) {\n        if (tracker.unfinished()) {\n            console.log('');\n            console.log('FAILURES: Undone tests (or their setups/teardowns): ');\n            var names = tracker.names();\n            for (var i = 0; i < names.length; i += 1) {\n                console.log('- ' + names[i]);\n            }\n            console.log('');\n            console.log('To fix this, make sure all tests call test.done()');\n            process.reallyExit(tracker.unfinished());\n        }\n    });\n\n    nodeunit.runFiles(paths, {\n        testspec: undefined,\n        moduleStart: function (name) {\n            console.log('\\n' + name);\n        },\n        testDone: function (name, assertions) {\n            tracker.remove(name);\n\n            if (!assertions.failures()) {\n                console.log(' ' + name);\n            }\n            else {\n                console.log(' ' + name + '\\n');\n                assertions.forEach(function (a) {\n                    if (a.failed()) {\n                        a = utils.betterErrors(a);\n                        if (a.error instanceof AssertionError && a.message) {\n                            console.log(\n                                'Assertion Message: ' + a.message\n                            );\n                        }\n                        console.log(a.error.stack + '\\n');\n                    }\n                });\n            }\n        },\n        done: function (assertions, end) {\n            var end = end || new Date().getTime();\n            var duration = end - start;\n            if (assertions.failures()) {\n                console.log(\n                    '\\n' + 'FAILURES: ' + assertions.failures() +\n                    '/' + assertions.length + ' assertions failed (' +\n                    assertions.duration + 'ms)'\n                );\n            }\n            else {\n                console.log(\n                   '\\n' + 'OK: ' + assertions.length +\n                   ' assertions (' + assertions.duration + 'ms)'\n                );\n            }\n\n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        },\n        testStart: function (name) {\n            tracker.put(name);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/machineout.js":"/*!\n * Nodeunit\n *\n * @author  Alisue (lambdalisue@hashnote.net)\n * @url     http://hashnote.net/\n *\n * Copyright (c) 2011 Alisue\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    track = require('../track'),\n    path = require('path'),\n    AssertionError = require('../assert').AssertionError;\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Tests reporter for machinally analysis\";\n\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n    // options doesn't effect\n\n    var parseStack = function (stack, delimiter) {\n        var parseTrace = function (trace) {\n            var filename, row, column;\n            pattern1 = /\\s{4}at\\s\\S+\\s\\(([^:]+):(\\d+):(\\d+)\\)/;\n            pattern2 = /\\s{4}at\\s([^:]+):(\\d+):(\\d+)/;\n\n            if (trace.match(pattern1) !== null) {\n                filename = RegExp.$1;\n                row = RegExp.$2;\n                column = RegExp.$3;\n            } else if (trace.match(pattern2) !== null) {\n                filename = RegExp.$1;\n                row = RegExp.$2;\n                column = RegExp.$3;\n            } else {\n                throw new Error(\"Could not parse a line of stack trace: \" + trace);\n            }\n            return {filename: filename, row: row, column: column};\n        };\n        if (delimiter === undefined) {\n            delimiter = ':';\n        }\n        traceback = stack.split('\\n');\n        firstline = traceback.shift();\n        trace = parseTrace(traceback[0]);\n        return {filename: trace.filename, row: trace.row, column: trace.column, message: firstline};\n    };\n    var createErrorMessage = function(type, name, filename, row, column, message){\n        return [type, name, filename, row, column, message].join(\":\");\n    };\n    var paths = files.map(function (p) {\n        return path.resolve(p);\n    });\n    var tracker = track.createTracker(function (tracker) {\n        if (tracker.unfinished()) {\n            var names = tracker.names();\n            for (var i = 0; i < names.length; i += 1) {\n                console.log(createErrorMessage(\n                    'Error', names[i], \n                    '', '', '', \n                    'Undone tests - To fix this, make sure all tests call test.done()'\n                ));\n            }\n            process.reallyExit(tracker.unfinished());\n        }\n    });\n\n    nodeunit.runFiles(paths, {\n        testspec: options.testspec,\n        testFullSpec: options.testFullSpec,\n        moduleStart: function (name) {},\n        testDone: function (name, assertions) {\n            tracker.remove(name);\n            if (assertions.failures()) {\n                assertions.forEach(function (a) {\n                    var stacks, message, filename, row, column;\n                    if (a.failed()) {\n                        stackinfo = parseStack(a.error.stack, ':');\n                        console.log(createErrorMessage(\n                            'Fail', name, stackinfo.filename,\n                            stackinfo.row, stackinfo.column, stackinfo.message));\n                    }\n                });\n            }\n        },\n        done: function (assertions, end) {\n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        },\n        testStart: function(name) {\n            tracker.put(name);\n        }\n    });\n};\n\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/nested.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    track = require('../track'),\n    path = require('path'),\n    AssertionError = require('../assert').AssertionError;\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Nested test reporter\";\n\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    if (!options) {\n        // load default options\n        var content = fs.readFileSync(\n            __dirname + '/../../bin/nodeunit.json',\n            'utf8'\n        );\n        options = JSON.parse(content);\n    }\n\n    var error = function (str) {\n        return options.error_prefix + str + options.error_suffix;\n    };\n    var ok    = function (str) {\n        return options.ok_prefix + str + options.ok_suffix;\n    };\n    var bold  = function (str) {\n        return options.bold_prefix + str + options.bold_suffix;\n    };\n    var assertion_message = function (str) {\n        return options.assertion_prefix + str + options.assertion_suffix;\n    };\n    var fail_indicator = process.platform === 'win32' ? '\\u00D7' : '';\n\n    var spaces_per_indent = options.spaces_per_indent || 4;\n\n    var start = new Date().getTime();\n    var paths = files.map(function (p) {\n        return path.resolve(p);\n    });\n    var tracker = track.createTracker(function (tracker) {\n        var i, names;\n        if (tracker.unfinished()) {\n            console.log('');\n            console.log(error(bold(\n                'FAILURES: Undone tests (or their setups/teardowns): '\n            )));\n            names = tracker.names();\n            for (i = 0; i < names.length; i += 1) {\n                console.log('- ' + names[i]);\n            }\n            console.log('');\n            console.log('To fix this, make sure all tests call test.done()');\n            process.reallyExit(tracker.unfinished());\n        }\n    });\n\n    // Object to hold status of each 'part' of the testCase/name array,\n    // i.e., whether this part has been printed yet.\n    tracker.already_printed = {};\n\n    var pass_text = function (txt) {\n        // Print in bold green.\n        return bold(ok(txt + \" (pass)\"));\n    };\n\n    var fail_text = function (txt) {\n        return bold(error(txt + \" (fail) \" + fail_indicator + \" \"));\n    };\n\n    var status_text = function (txt, status) {\n        if (status === 'pass') {\n            return pass_text(txt);\n        } else {\n            return fail_text(txt);\n        }\n    };\n\n    /**\n     *  Slices an array, returns a string by joining the sliced elements.\n     *  @example\n     *   > name_slice(['TC1', 'TC1.1', 'mytest'], 1);\n     *   \"TC1,TC1.1\"\n     */\n    var name_slice = function (name_arr, end_index) {\n        return name_arr.slice(0, end_index + 1).join(\",\");\n    };\n\n    var indent = (function () {\n        var txt = '';\n        var i;\n        for (i = 0; i < spaces_per_indent; i++) {\n            txt += ' ';\n        }\n        return txt;\n    }());\n\n    // Indent once for each indent_level\n    var add_indent = function (txt, indent_level) {\n        var k;\n        for (k = 0; k < indent_level; k++) {\n            txt += indent;\n        }\n        return txt;\n    };\n\n    // If it's not the last element of the name_arr, it's a testCase.\n    var is_testCase = function (name_arr, index) {\n        return index === name_arr.length - 1 ? false : true;\n    };\n\n    var testCase_line = function (txt) {\n        return txt + \"\\n\";\n    };\n\n    /**\n     * Prints (console.log) the nested test status line(s).\n     *\n     * @param {Array} name_arr - Array of name elements.\n     * @param {String} status - either 'pass' or 'fail'.\n     * @example\n     *   > print_status(['TC1', 'TC1.1', 'mytest'], 'pass');\n     *   TC1\n     *      TC1.1\n     *         mytest (pass)\n     */\n    var print_status = function (name_arr, status) {\n        var txt = '';\n        var _name_slice, part, i;\n        for (i = 0; i < name_arr.length; i++) {\n            _name_slice = name_slice(name_arr, i);\n            part = name_arr[i];\n            if (!tracker.already_printed[_name_slice]) {\n                txt = add_indent(txt, i);\n                if (is_testCase(name_arr, i)) {\n                    txt += testCase_line(part);\n                } else {\n                    txt += status_text(part, status);\n                }\n                tracker.already_printed[_name_slice] = true;\n            }\n        }\n        console.log(txt);\n    };\n\n    nodeunit.runFiles(paths, {\n        testspec: options.testspec,\n        testFullSpec: options.testFullSpec,\n        moduleStart: function (name) {\n            console.log('\\n' + bold(name));\n        },\n        testDone: function (name, assertions) {\n            tracker.remove(name);\n\n            if (!assertions.failures()) {\n                print_status(name, 'pass');\n            } else {\n                print_status(name, 'fail');\n                assertions.forEach(function (a) {\n                    if (a.failed()) {\n                        a = utils.betterErrors(a);\n                        if (a.error instanceof AssertionError && a.message) {\n                            console.log(\n                                'Assertion Message: ' +\n                                    assertion_message(a.message)\n                            );\n                        }\n                        console.log(a.error.stack + '\\n');\n                    }\n                });\n            }\n        },\n        done: function (assertions, end) {\n            end = end || new Date().getTime();\n            var duration = end - start;\n            if (assertions.failures()) {\n                console.log(\n                    '\\n' + bold(error('FAILURES: ')) + assertions.failures() +\n                        '/' + assertions.length + ' assertions failed (' +\n                        assertions.duration + 'ms)'\n                );\n            } else {\n                console.log(\n                    '\\n' + bold(ok('OK: ')) + assertions.length +\n                        ' assertions (' + assertions.duration + 'ms)'\n                );\n            }\n            \n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        },\n        testStart: function (name) {\n            tracker.put(name);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/verbose.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n */\n\n/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    utils = require('../utils'),\n    fs = require('fs'),\n    track = require('../track'),\n    path = require('path'),\n    AssertionError = require('../assert').AssertionError;\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Verbose tests reporter\"\n\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    if (!options) {\n        // load default options\n        var content = fs.readFileSync(\n            __dirname + '/../../bin/nodeunit.json', 'utf8'\n        );\n        options = JSON.parse(content);\n    }\n\n    var error = function (str) {\n        return options.error_prefix + str + options.error_suffix;\n    };\n    var ok    = function (str) {\n        return options.ok_prefix + str + options.ok_suffix;\n    };\n    var bold  = function (str) {\n        return options.bold_prefix + str + options.bold_suffix;\n    };\n    var assertion_message = function (str) {\n        return options.assertion_prefix + str + options.assertion_suffix;\n    };\n    var pass_indicator = process.platform === 'win32' ? '\\u221A' : '';\n    var fail_indicator = process.platform === 'win32' ? '\\u00D7' : '';\n\n    var start = new Date().getTime();\n    var paths = files.map(function (p) {\n        return path.resolve(p);\n    });\n    var tracker = track.createTracker(function (tracker) {\n        if (tracker.unfinished()) {\n            console.log('');\n            console.log(error(bold(\n                'FAILURES: Undone tests (or their setups/teardowns): '\n            )));\n            var names = tracker.names();\n            for (var i = 0; i < names.length; i += 1) {\n                console.log('- ' + names[i]);\n            }\n            console.log('');\n            console.log('To fix this, make sure all tests call test.done()');\n            process.reallyExit(tracker.unfinished());\n        }\n    });\n\n    nodeunit.runFiles(paths, {\n        testspec: options.testspec,\n        testFullSpec: options.testFullSpec,\n        moduleStart: function (name) {\n            console.log('\\n' + bold(name));\n        },\n        testDone: function (name, assertions) {\n            tracker.remove(name);\n\n            if (!assertions.failures()) {\n                console.log(pass_indicator + ' ' + name);\n            }\n            else {\n                console.log(error(fail_indicator + ' ' + name));\n            }\n            // verbose so print everything\n            assertions.forEach(function (a) {\n              if (a.failed()) {\n                console.log(error('  ' + fail_indicator + ' ' + a.message));\n                a = utils.betterErrors(a);\n                console.log('  ' + a.error.stack);\n              }\n              else {\n                console.log('  ' + pass_indicator + ' ' + a.message);\n              }\n            });\n        },\n        done: function (assertions, end) {\n            var end = end || new Date().getTime();\n            var duration = end - start;\n            if (assertions.failures()) {\n                console.log(\n                    '\\n' + bold(error('FAILURES: ')) + assertions.failures() +\n                    '/' + assertions.length + ' assertions failed (' +\n                    assertions.duration + 'ms)'\n                );\n            }\n            else {\n                console.log(\n                   '\\n' + bold(ok('OK: ')) + assertions.length +\n                   ' assertions (' + assertions.duration + 'ms)'\n                );\n            }\n            \n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        },\n        testStart: function(name) {\n            tracker.put(name);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/lcov.js":"/**\n * Module dependencies\n */\n\nvar nodeunit = require('../nodeunit'),\n    path = require('path');\n\n/**\n * Reporter info string\n */\n\nexports.info = 'The LCOV reporter reads JS files instrumented by JSCoverage (http://siliconforks.com/jscoverage/) and outputs coverage data in the LCOV format (http://ltp.sourceforge.net/coverage/lcov/geninfo.1.php)';\n\n/**\n * Run all tests within each module, reporting the results to the command-line.\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (files, options, callback) {\n\n    var paths = files.map(function (p) {\n        return path.resolve(p);\n    });\n    \n    nodeunit.runFiles(paths, {\n        done: function (assertions) {\n            var cov = (global || window)._$jscoverage || {};\n\n            Object.keys(cov).forEach(function (filename) {\n                var data = cov[filename];\n                reportFile(filename, data);\n            });\n            \n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        }\n    });\n};\n\nfunction reportFile(filename, data) {\n    console.log('SF:' + filename);\n\n    data.source.forEach(function(line, num) {\n        // increase the line number, as JS arrays are zero-based\n        num++;\n\n        if (data[num] !== undefined) {\n            console.log('DA:' + num + ',' + data[num]);\n        }\n    });\n\n    console.log('end_of_record');\n}\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/deps/json2.js":"/*\n    http://www.JSON.org/json2.js\n    2010-11-17\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    See http://www.JSON.org/js.html\n\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n\n\n    This file creates a global JSON object containing two methods: stringify\n    and parse.\n\n        JSON.stringify(value, replacer, space)\n            value       any JavaScript value, usually an object or array.\n\n            replacer    an optional parameter that determines how object\n                        values are stringified for objects. It can be a\n                        function or an array of strings.\n\n            space       an optional parameter that specifies the indentation\n                        of nested structures. If it is omitted, the text will\n                        be packed without extra whitespace. If it is a number,\n                        it will specify the number of spaces to indent at each\n                        level. If it is a string (such as '\\t' or '&nbsp;'),\n                        it contains the characters used to indent at each level.\n\n            This method produces a JSON text from a JavaScript value.\n\n            When an object value is found, if the object contains a toJSON\n            method, its toJSON method will be called and the result will be\n            stringified. A toJSON method does not serialize: it returns the\n            value represented by the name/value pair that should be serialized,\n            or undefined if nothing should be serialized. The toJSON method\n            will be passed the key associated with the value, and this will be\n            bound to the value\n\n            For example, this would serialize Dates as ISO strings.\n\n                Date.prototype.toJSON = function (key) {\n                    function f(n) {\n                        // Format integers to have at least two digits.\n                        return n < 10 ? '0' + n : n;\n                    }\n\n                    return this.getUTCFullYear()   + '-' +\n                         f(this.getUTCMonth() + 1) + '-' +\n                         f(this.getUTCDate())      + 'T' +\n                         f(this.getUTCHours())     + ':' +\n                         f(this.getUTCMinutes())   + ':' +\n                         f(this.getUTCSeconds())   + 'Z';\n                };\n\n            You can provide an optional replacer method. It will be passed the\n            key and value of each member, with this bound to the containing\n            object. The value that is returned from your method will be\n            serialized. If your method returns undefined, then the member will\n            be excluded from the serialization.\n\n            If the replacer parameter is an array of strings, then it will be\n            used to select the members to be serialized. It filters the results\n            such that only members with keys listed in the replacer array are\n            stringified.\n\n            Values that do not have JSON representations, such as undefined or\n            functions, will not be serialized. Such values in objects will be\n            dropped; in arrays they will be replaced with null. You can use\n            a replacer function to replace those with JSON values.\n            JSON.stringify(undefined) returns undefined.\n\n            The optional space parameter produces a stringification of the\n            value that is filled with line breaks and indentation to make it\n            easier to read.\n\n            If the space parameter is a non-empty string, then that string will\n            be used for indentation. If the space parameter is a number, then\n            the indentation will be that many spaces.\n\n            Example:\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}]);\n            // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\\t');\n            // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\n            text = JSON.stringify([new Date()], function (key, value) {\n                return this[key] instanceof Date ?\n                    'Date(' + this[key] + ')' : value;\n            });\n            // text is '[\"Date(---current time---)\"]'\n\n\n        JSON.parse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = JSON.parse(text, function (key, value) {\n                var a;\n                if (typeof value === 'string') {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n            myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n                var d;\n                if (typeof value === 'string' &&\n                        value.slice(0, 5) === 'Date(' &&\n                        value.slice(-1) === ')') {\n                    d = new Date(value.slice(5, -1));\n                    if (d) {\n                        return d;\n                    }\n                }\n                return value;\n            });\n\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n*/\n\n/*jslint evil: true, strict: false, regexp: false */\n\n/*members \"\", \"\\b\", \"\\t\", \"\\n\", \"\\f\", \"\\r\", \"\\\"\", JSON, \"\\\\\", apply,\n    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\nvar JSON = {};\n\n(function () {\n    \"use strict\";\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10 ? '0' + n : n;\n    }\n\n    if (typeof Date.prototype.toJSON !== 'function') {\n\n        Date.prototype.toJSON = function (key) {\n\n            return isFinite(this.valueOf()) ?\n                   this.getUTCFullYear()   + '-' +\n                 f(this.getUTCMonth() + 1) + '-' +\n                 f(this.getUTCDate())      + 'T' +\n                 f(this.getUTCHours())     + ':' +\n                 f(this.getUTCMinutes())   + ':' +\n                 f(this.getUTCSeconds())   + 'Z' : null;\n        };\n\n        String.prototype.toJSON =\n        Number.prototype.toJSON =\n        Boolean.prototype.toJSON = function (key) {\n            return this.valueOf();\n        };\n    }\n\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        gap,\n        indent,\n        meta = {    // table of character substitutions\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"' : '\\\\\"',\n            '\\\\': '\\\\\\\\'\n        },\n        rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        escapable.lastIndex = 0;\n        return escapable.test(string) ?\n            '\"' + string.replace(escapable, function (a) {\n                var c = meta[a];\n                return typeof c === 'string' ? c :\n                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n            }) + '\"' :\n            '\"' + string + '\"';\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i,          // The loop counter.\n            k,          // The member key.\n            v,          // The member value.\n            length,\n            mind = gap,\n            partial,\n            value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === 'function') {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case 'string':\n            return quote(value);\n\n        case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value) ? String(value) : 'null';\n\n        case 'boolean':\n        case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n        case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n            if (!value) {\n                return 'null';\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0 ? '[]' :\n                    gap ? '[\\n' + gap +\n                            partial.join(',\\n' + gap) + '\\n' +\n                                mind + ']' :\n                          '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0 ? '{}' :\n                gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n                        mind + '}' : '{' + partial.join(',') + '}';\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    if (typeof JSON.stringify !== 'function') {\n        JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n            var i;\n            gap = '';\n            indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n            if (typeof space === 'number') {\n                for (i = 0; i < space; i += 1) {\n                    indent += ' ';\n                }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n            } else if (typeof space === 'string') {\n                indent = space;\n            }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n            rep = replacer;\n            if (replacer && typeof replacer !== 'function' &&\n                    (typeof replacer !== 'object' ||\n                     typeof replacer.length !== 'number')) {\n                throw new Error('JSON.stringify');\n            }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n            return str('', {'': value});\n        };\n    }\n\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== 'function') {\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k, v, value = holder[key];\n                if (value && typeof value === 'object') {\n                    for (k in value) {\n                        if (Object.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            cx.lastIndex = 0;\n            if (cx.test(text)) {\n                text = text.replace(cx, function (a) {\n                    return '\\\\u' +\n                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with '()' and 'new'\n// because they can cause invocation, and '=' because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n// replace all simple value tokens with ']' characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or ']' or\n// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n            if (/^[\\],:{}\\s]*$/\n.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n.replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n.replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval('(' + text + ')');\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return typeof reviver === 'function' ?\n                    walk({'': j}, '') : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError('JSON.parse');\n        };\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/share/license.js":"/*!\n * Nodeunit\n * https://github.com/caolan/nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n *\n * json2.js\n * http://www.JSON.org/json2.js\n * Public Domain.\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n */\n","/home/travis/build/npmtest/node-npmtest-nodeunit/node_modules/nodeunit/lib/reporters/browser.js":"/*!\n * Nodeunit\n * Copyright (c) 2010 Caolan McMahon\n * MIT Licensed\n *\n * THIS FILE SHOULD BE BROWSER-COMPATIBLE JS!\n * You can use @REMOVE_LINE_FOR_BROWSER to remove code from the browser build.\n * Only code on that line will be removed, its mostly to avoid requiring code\n * that is node specific\n */\n\n\n/**\n * NOTE: this test runner is not listed in index.js because it cannot be\n * used with the command-line tool, only inside the browser.\n */\n\n\n/**\n * Reporter info string\n */\n\nexports.info = \"Browser-based test reporter\";\n\n\n/**\n * Run all tests within each module, reporting the results\n *\n * @param {Array} files\n * @api public\n */\n\nexports.run = function (modules, options, callback) {\n    var start = new Date().getTime(), div, textareas, displayErrorsByDefault;\n    options = options || {};\n    div = options.div || document.body;\n    textareas = options.textareas;\n    displayErrorsByDefault = options.displayErrorsByDefault;\n\n    function setText(el, txt) {\n        if ('innerText' in el) {\n            el.innerText = txt;\n        }\n        else if ('textContent' in el){\n            el.textContent = txt;\n        }\n    }\n\n    function getOrCreate(tag, id) {\n        var el = document.getElementById(id);\n        if (!el) {\n            el = document.createElement(tag);\n            el.id = id;\n            div.appendChild(el);\n        }\n        return el;\n    };\n\n    var header = getOrCreate('h1', 'nodeunit-header');\n    var banner = getOrCreate('h2', 'nodeunit-banner');\n    var userAgent = getOrCreate('h2', 'nodeunit-userAgent');\n    var tests = getOrCreate('ol', 'nodeunit-tests');\n    var result = getOrCreate('p', 'nodeunit-testresult');\n\n    setText(userAgent, navigator.userAgent);\n\n    nodeunit.runModules(modules, {\n        moduleStart: function (name) {\n            /*var mheading = document.createElement('h2');\n            mheading.innerText = name;\n            results.appendChild(mheading);\n            module = document.createElement('ol');\n            results.appendChild(module);*/\n        },\n        testDone: function (name, assertions) {\n            var test = document.createElement('li');\n            var strong = document.createElement('strong');\n            strong.innerHTML = name + ' <b style=\"color: black;\">(' +\n                '<b class=\"fail\">' + assertions.failures() + '</b>, ' +\n                '<b class=\"pass\">' + assertions.passes() + '</b>, ' +\n                assertions.length +\n            ')</b>';\n            test.className = assertions.failures() ? 'fail': 'pass';\n            test.appendChild(strong);\n\n            var aList = document.createElement('ol');\n            aList.style.display = displayErrorsByDefault ? 'block' : 'none';\n            (displayErrorsByDefault ? strong : test).onclick = function () {\n                var d = aList.style.display;\n                aList.style.display = (d == 'none') ? 'block': 'none';\n            };\n            for (var i=0; i<assertions.length; i++) {\n                var li = document.createElement('li');\n                var a = assertions[i];\n                if (a.failed()) {\n                    li.innerHTML = (a.message || a.method || 'no message') +\n                        (textareas ?\n                          '<textarea rows=\"20\" cols=\"100\">' + (a.error.stack || a.error) + '</textarea>' :\n                          '<pre>' + (a.error.stack || a.error) + '</pre>');\n                    li.className = 'fail';\n                }\n                else {\n                    li.innerHTML = a.message || a.method || 'no message';\n                    li.className = 'pass';\n                }\n                aList.appendChild(li);\n            }\n            test.appendChild(aList);\n            tests.appendChild(test);\n        },\n        done: function (assertions) {\n            var end = new Date().getTime();\n            var duration = end - start;\n\n            var failures = assertions.failures();\n            banner.className = failures ? 'fail': 'pass';\n\n            result.innerHTML = 'Tests completed in ' + duration +\n                ' milliseconds.<br/><span class=\"passed\">' +\n                assertions.passes() + '</span> assertions of ' +\n                '<span class=\"all\">' + assertions.length + '<span> passed, ' +\n                assertions.failures() + ' failed.';\n\n            if (callback) callback(assertions.failures() ? new Error('We have got test failures.') : undefined);\n        }\n    });\n};\n"}